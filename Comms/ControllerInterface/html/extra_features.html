<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>rfm12lib: Extra Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Source&nbsp;Documentation</span></a></li>
      <li><a href="globals.html"><span>Alphabetical&nbsp;Index</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="extra_features">Extra Features </a></h1><h2><a class="anchor" id="feature_ctrl_sec">
Live Control Feature</a></h2>
<p>Usually the module is configured by <a class="el" href="rfm12_8c.html#a435d3650bfc7c165fb430a8d4527ef7b" title="This is the main library initialization function.">rfm12_init()</a> using the values defined in the configuration header. However, one might want to change the frequency, baud rate or other settings during operation, for example to implement channel hopping or a radio scanner to find frequencies which are in use. By setting RFM12_LIVECTRL to 1 in the configuration header, additional functions are enabled to conveniently reprogram the module during runtime. These live control functions can be found in <a class="el" href="rfm12__ctrl_8h.html" title="rfm12 library live control feature header">rfm12_ctrl.h</a>. You do not need to include this header, this is already done by <a class="el" href="rfm12_8h.html" title="rfm12 library main header">rfm12.h</a>. Currently there are only functions to set the baud rate and frequency.</p>
<p>The baud rate is set by <a class="el" href="rfm12__ctrl_8c.html#a536799ba63d28d3c970d17434b8a42b9" title="Set the data rate of the rf12.">rfm12_set_rate()</a> and the frequency is set by <a class="el" href="rfm12__ctrl_8c.html#a48552b34e3f4aac8e0c8cab059cc6bd8" title="Set the frequency of the rf12.">rfm12_set_frequency()</a>. Both accept a parameter that has to be calculated according to the RF12 datasheet. The configuration header utilizes macros to calculate these parameter values during compile time. However, these macros are not included as real code, to reduce the size of the binary.</p>
<p>You could implement these calculations by yourself, or create lookup-tables with precomputed values for specific baud rates and frequencies. This way you can support a set of the most common baud rates or have a fixed frequency hopping schedule.</p>
<p>The macros for baud rate calculation are RFM12_DATARATE_CALC_HIGH() and RFM12_DATARATE_CALC_LOW(). Refer to the <a class="el" href="index.html#conf_rfm12_sec">RFM12 configuration section</a> for usage examples. The frequency parameters can be obtained by using RFM12_FREQUENCY_CALC_433(), RFM12_FREQUENCY_CALC_868() or RFM12_FREQUENCY_CALC_915(), each for the specific frequency band.</p>
<p>You will have to include rfm12_hw.h for the macros to work.</p>
<h2><a class="anchor" id="feature_ask_sec">
ASK Modulation Feature</a></h2>
<p>Although the RF12 modules do not support ASK (amplitude shift keying) modulation natively it is still possible to emulate it in software. In contrast to FSK (frequency shift keying) where ones and zeroes are encoded using different frequencies, ASK encodes data using the amplitude of a radio signal. The following subsections explain how this library emulates ASK data transmission and reception.</p>
<h3><a class="anchor" id="feature_ask_rx">
ASK Data Reception</a></h3>
<p>To decode ASK modulated data, one needs to measure the amplitude of a radio signal and map it to ones or zeroes. Luckily the RFM12 provides an analog RSSI (receive signal strength indicator) pin, which can be attached to the ADC of an AVR microcontroller in order to measure the signal strength. As the signal strength can be interpreted as the amplitude it is possible to decode an ASK signal by setting a threshold and mapping all signal strength measurements greater than that threshold to ones and the other ones to zero respectively. This library provides an ADC interrupt which is able to decode ASK signals.</p>
<p>To use the ASK receive mode, just set RFM12_RECEIVE_ASK to 1 and call <a class="el" href="rfm12__extra_8c.html#a2b815e6730e8723a6d1d06d9ef8f31c0" title="ASK mode ADC interrupt setup.">adc_init()</a> at the beginning of your application. Received data is stored in ask_rxbuf (<a class="el" href="structrfm12__rfrxbuf__t.html" title="The receive buffer structure for the amplitude modulated receive feature.">rfm12_rfrxbuf_t</a>) and can be read if ask_rxbuf.state is set to RFM12_ASK_STATE_FULL. The received data is stored as pulse lengths in timer 0 counts inside ask_rxbuf. This way two or more consecutive ones or zeroes are interpreted as one longer pulse. As every transmission begins with a one (for technical reasons), all even buffer array indices are pulse lengths of ones, while all even odd indices are zeroes. This is due to the bit packing. Please note that you have to initialize timer 0 and probably adjust some values in the ADC interrupt service routine to fit your application.</p>
<h3><a class="anchor" id="feature_ask_tx">
ASK Data Transmission</a></h3>
<p>ASK modulated data transmission is emulated by filling the RF12 transmit buffer with ones and turning the transmitter on and off. As the RF12 natively uses FSK modulation, the transmitter will generate a carrier signal when turned on and transmitting. Cheap ASK devices like radio controlled power outlets and the like will interprete the carrier signal as a one and no carrier signal as a zero. Unfortunately this library does not supply functions to transmit binary data, but supplies functions to control the transmitter and create ones and zeroes. Encoding data is left to the user.</p>
<p>The ASK transmission feature is enabled by setting RFM12_TRANSMIT_ASK to 1. ASK transmit mode can be enabled with <a class="el" href="rfm12__extra_8c.html#a6e836bfa17609b3e937902eaba82f040" title="En- or disable ASK transmissions.">rfm12_ask_tx_mode()</a>, while <a class="el" href="rfm12__extra_8c.html#a07c6cf0e0a1a6dedc31e05ff4fca35a3" title="Enable the transmitter immediately (ASK transmission mode).">rfm12_tx_on()</a> and <a class="el" href="rfm12__extra_8c.html#a9c2aa5cfb23d974d8a6c91a08487d76e" title="Set default power mode (usually transmitter off, receiver on).">rfm12_tx_off()</a> control the transmitter to encode ones and zeroes.</p>
<p>There are several web-resources in German language which explain the encoding used by radio controlled outlets: <a href="http://www.das-labor.org/wiki/Diskussion:Funkfernbedienung">http://www.das-labor.org/wiki/Diskussion:Funkfernbedienung</a> <a href="http://ethersex.de/index.php/HowToRFM12_ASK">http://ethersex.de/index.php/HowToRFM12_ASK</a></p>
<h2><a class="anchor" id="feature_wakeup_sec">
Wakeup Timer Feature</a></h2>
<p>The RF12 supports a wakeup timer mode that only consumes a few microamperes of power. This is useful if you want to save battery life by putting your microcontroller to sleep and just let it wake up periodically to check if there's anything new. The library can put the module into this mode and handle wakeup interrupts by setting RFM12_USE_WAKEUP_TIMER to 1. When the wakeup timer feature is enabled, the function <a class="el" href="rfm12__extra_8c.html#a357533c48a701e5a1491dd6e82a31ae6" title="This function sets the wakeup timer register.">rfm12_set_wakeup_timer()</a> will become available. Although the function is located in <a class="el" href="rfm12__extra_8h.html" title="rfm12 library extra features header">rfm12_extra.h</a>, you won't need to include this header, as this is already done by <a class="el" href="rfm12_8h.html" title="rfm12 library main header">rfm12.h</a>.</p>
<p>It is advised to configure the wakeup timer once after calling <a class="el" href="rfm12_8c.html#a435d3650bfc7c165fb430a8d4527ef7b" title="This is the main library initialization function.">rfm12_init()</a>, though you could re-configure it anytime, theoretically. The function accepts a parameter which has to be formatted according to the RF12 datasheet. The wakeup timer period can be configured from 1ms to a span of multiple days.</p>
<p>There might be some problems when using the wakeup timer. It will work properly most of the time, but in some situations, it never wakes up the microcontroller from sleep mode, effectively stopping your application. This is due to missed interrupts. Upon every wakeup interrupt, the wakeup timer has to be reset. It might occur that an wakeup timer intterupt flag is not interpreted correctly by the interrupt when transmissions take place, thereby not resetting the wakeup mode. These problems also seem to be application and configuration specific. Depending on the library configuration, there are more or less opportunities to miss an interrupt. Disabling the receive mode, for example, should reduce the errors, but on the other hand, a disabled collision detection reduces the libraries chances to recover, as the collision detection might reset failed interrupt states.</p>
<p>If you experience any unsolvable problems, try to make the interrupt routine non-interruptible by removing the ISR_NOBLOCK parameter from its function definition and set the interrupt to negative-level triggered, instead of negative-edge triggered.</p>
<h2><a class="anchor" id="feature_lbd_sec">
Low-Battery Detector Feature</a></h2>
<p>The RF12 also has a built-in low-battery detector. To use this feature, define RFM12_LOW_POWER as 1 in the configuration header and use <a class="el" href="rfm12__extra_8c.html#a07eb455d99d583edce48c8bd8bd0f377" title="This function sets the low battery detector and microcontroller clock divider register...">rfm12_set_batt_detector()</a> to set the threshold voltage on which an alarm is generated and <a class="el" href="rfm12__extra_8c.html#a07f231285fa4d71395fe3344d6f265a5" title="Return the current low battery detector status.">rfm12_get_batt_status()</a> to retreive the current battery status. The battery voltage threshold can be set anywhere from 2.2 volts to the supply voltage of the module in 0.1V increments. To use this feature, you do not need to include <a class="el" href="rfm12__extra_8h.html" title="rfm12 library extra features header">rfm12_extra.h</a>, as this is already done by <a class="el" href="rfm12_8h.html" title="rfm12 library main header">rfm12.h</a>.</p>
<p>To set the threshold voltage you need to pass a parameter which is calculated according to the RF12 datasheet to <a class="el" href="rfm12__extra_8c.html#a07eb455d99d583edce48c8bd8bd0f377" title="This function sets the low battery detector and microcontroller clock divider register...">rfm12_set_batt_detector()</a>; The formula is Vlb = 2.2 + (val * 0.1), where Vlb is the threshold voltage and val is the parameter. <a class="el" href="rfm12__extra_8c.html#a07f231285fa4d71395fe3344d6f265a5" title="Return the current low battery detector status.">rfm12_get_batt_status()</a> will return <a class="el" href="rfm12__extra_8h.html#batt_states">RFM12_BATT_OKAY</a> or <a class="el" href="rfm12__extra_8h.html#batt_states">RFM12_BATT_LOW</a> to indicate the current battery status. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>
<span style="float:left" ><a href="http://www.das-labor.org"><img src="labor.png" style="border:0px" /><br /><b>Das LABOR</b></a></span>
Generated on Tue Nov 3 17:18:05 2009 for rfm12lib by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1</small></address>
</body>
</html>
