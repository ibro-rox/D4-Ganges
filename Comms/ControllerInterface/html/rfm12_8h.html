<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>rfm12lib: rfm12.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Source&nbsp;Documentation</span></a></li>
      <li><a href="globals.html"><span>Alphabetical&nbsp;Index</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>rfm12.h File Reference</h1>
<p>rfm12 library main header  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="rfm12__extra_8h_source.html">include/rfm12_extra.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rfm12__ctrl_8h_source.html">include/rfm12_ctrl.h</a>&quot;</code><br/>

<p><a href="rfm12_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrf__tx__buffer__t.html">rf_tx_buffer_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The transmission buffer structure.  <a href="structrf__tx__buffer__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrf__rx__buffer__t.html">rf_rx_buffer_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The receive buffer structure.  <a href="structrf__rx__buffer__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrfm12__control__t.html">rfm12_control_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Control and status structure.  <a href="structrfm12__control__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">States for rx and tx buffers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp452b798c1b221819a31ac77651f132dd"></a> <a class="anchor" id="rxtx_states"></a> </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201" title="Inline function to return the rx buffer status byte.">rfm12_rx_status()</a> and <a class="el" href="structrfm12__control__t.html" title="Control and status structure.">rfm12_control_t</a> </dd></dl>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a2f6554a43a39a3ca2e1d043d56e29a6f">STATUS_FREE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that the buffer is free.  <a href="#a2f6554a43a39a3ca2e1d043d56e29a6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#abb8285eb58799200ca84d5cbe61744ca">STATUS_OCCUPIED</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that the buffer is in use by the library.  <a href="#abb8285eb58799200ca84d5cbe61744ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a3f09426d0c1debe202086668a7f1d7bf">STATUS_COMPLETE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that a receive buffer holds a complete transmission.  <a href="#a3f09426d0c1debe202086668a7f1d7bf"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Return values for rfm12_tx() and rfm12_start_tx()</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpee989965f4345b2c86761905c5c9043d"></a> <a class="anchor" id="tx_retvals"></a> </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> and <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> </dd></dl>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#aab261fa1f9f0c623bd59cae294810bb2">RFM12_TX_ERROR</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The packet data is longer than the internal buffer.  <a href="#aab261fa1f9f0c623bd59cae294810bb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a26c3d1c42187487ad29eb201855d52e6">RFM12_TX_OCCUPIED</a>&nbsp;&nbsp;&nbsp;0x03</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The transmit buffer is already occupied.  <a href="#a26c3d1c42187487ad29eb201855d52e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a87e8e7d862a36aa1f267f6c6ebeeafd3">RFM12_TX_ENQUEUED</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The packet has been enqueued successfully.  <a href="#a87e8e7d862a36aa1f267f6c6ebeeafd3"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a435d3650bfc7c165fb430a8d4527ef7b">rfm12_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the main library initialization function.  <a href="#a435d3650bfc7c165fb430a8d4527ef7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#ae928504f5cf2cbe4f894affc4faa2398">rfm12_tick</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The tick function implements collision avoidance and initiates transmissions.  <a href="#ae928504f5cf2cbe4f894affc4faa2398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#adf41f135b72ab0966e5cc43d20d9d864">rfm12_rx_clear</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to clear buffer complete/occupied status.  <a href="#adf41f135b72ab0966e5cc43d20d9d864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#ac5f9a9b05964d24b485e5501cfbb98a4">rfm12_start_tx</a> (uint8_t type, uint8_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue an already buffered packet for transmission.  <a href="#ac5f9a9b05964d24b485e5501cfbb98a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a6e9c9b38d4436b312818b8544d6d19bd">rfm12_tx</a> (uint8_t len, uint8_t type, uint8_t *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a packet to the buffer and call <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> to enqueue it for transmission.  <a href="#a6e9c9b38d4436b312818b8544d6d19bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201">rfm12_rx_status</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inline function to return the rx buffer status byte.  <a href="#ac5f459ab0857af6cd3651d03b1f0d201"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a118185e669a176439c45420f68967b84">rfm12_rx_len</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inline function to return the rx buffer length field.  <a href="#a118185e669a176439c45420f68967b84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#ab1e11af920e7f39c601bd42912debb5b">rfm12_rx_type</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inline function to return the rx buffer type field.  <a href="#ab1e11af920e7f39c601bd42912debb5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b">rfm12_rx_buffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inline function to retreive current rf buffer contents.  <a href="#a0ffa5a87f37bbc2af40850ce265da99b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrf__tx__buffer__t.html">rf_tx_buffer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#a4ad66f792bc6bccaf10747e4966d80f1">rf_tx_buffer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffer and status for packet transmission.  <a href="#a4ad66f792bc6bccaf10747e4966d80f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrf__rx__buffer__t.html">rf_rx_buffer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#ae4ba747a4678e4bba777437be15fb6e3">rf_rx_buffers</a> [2]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffers and status to receive packets.  <a href="#ae4ba747a4678e4bba777437be15fb6e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrfm12__control__t.html">rfm12_control_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8h.html#ac0e4e98fdca8a1582a541fac7351b08d">ctrl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global control and status.  <a href="#ac0e4e98fdca8a1582a541fac7351b08d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>rfm12 library main header </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Hans-Gert Dahmen </dd>
<dd>
Peter Fuhrmann </dd>
<dd>
Soeren Heisrath </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.9.0 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>08.09.09</dd></dl>
<p>This header represents the library's core API. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a87e8e7d862a36aa1f267f6c6ebeeafd3"></a><!-- doxytag: member="rfm12.h::RFM12_TX_ENQUEUED" ref="a87e8e7d862a36aa1f267f6c6ebeeafd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RFM12_TX_ENQUEUED&nbsp;&nbsp;&nbsp;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The packet has been enqueued successfully. </p>

</div>
</div>
<a class="anchor" id="aab261fa1f9f0c623bd59cae294810bb2"></a><!-- doxytag: member="rfm12.h::RFM12_TX_ERROR" ref="aab261fa1f9f0c623bd59cae294810bb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RFM12_TX_ERROR&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The packet data is longer than the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a26c3d1c42187487ad29eb201855d52e6"></a><!-- doxytag: member="rfm12.h::RFM12_TX_OCCUPIED" ref="a26c3d1c42187487ad29eb201855d52e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RFM12_TX_OCCUPIED&nbsp;&nbsp;&nbsp;0x03</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The transmit buffer is already occupied. </p>

</div>
</div>
<a class="anchor" id="a3f09426d0c1debe202086668a7f1d7bf"></a><!-- doxytag: member="rfm12.h::STATUS_COMPLETE" ref="a3f09426d0c1debe202086668a7f1d7bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATUS_COMPLETE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that a receive buffer holds a complete transmission. </p>

</div>
</div>
<a class="anchor" id="a2f6554a43a39a3ca2e1d043d56e29a6f"></a><!-- doxytag: member="rfm12.h::STATUS_FREE" ref="a2f6554a43a39a3ca2e1d043d56e29a6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATUS_FREE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that the buffer is free. </p>

</div>
</div>
<a class="anchor" id="abb8285eb58799200ca84d5cbe61744ca"></a><!-- doxytag: member="rfm12.h::STATUS_OCCUPIED" ref="abb8285eb58799200ca84d5cbe61744ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATUS_OCCUPIED&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that the buffer is in use by the library. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a435d3650bfc7c165fb430a8d4527ef7b"></a><!-- doxytag: member="rfm12.h::rfm12_init" ref="a435d3650bfc7c165fb430a8d4527ef7b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rfm12_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the main library initialization function. </p>
<p>This function takes care of all module initialization, including:</p>
<ul>
<li>Setup of the used frequency band and external capacitor</li>
<li>Setting the exact frequency (channel)</li>
<li>Setting the transmission data rate</li>
<li>Configuring various module related rx parameters, including the amplification</li>
<li>Enabling the digital data filter</li>
<li>Enabling the use of the modules fifo, as well as enabling sync pattern detection</li>
<li>Configuring the automatic frequency correction</li>
<li>Setting the transmit power</li>
</ul>
<p>This initialization function also sets up various library internal configuration structs and puts the module into receive mode before returning.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Please note that the transmit power and receive amplification values are currently hard coded. Have a look into rfm12_hw.h for possible settings. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ffa5a87f37bbc2af40850ce265da99b"></a><!-- doxytag: member="rfm12.h::rfm12_rx_buffer" ref="a0ffa5a87f37bbc2af40850ce265da99b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t* rfm12_rx_buffer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inline function to retreive current rf buffer contents. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the current receive buffer contents </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201" title="Inline function to return the rx buffer status byte.">rfm12_rx_status()</a>, <a class="el" href="rfm12_8h.html#a118185e669a176439c45420f68967b84" title="Inline function to return the rx buffer length field.">rfm12_rx_len()</a>, <a class="el" href="rfm12_8h.html#ab1e11af920e7f39c601bd42912debb5b" title="Inline function to return the rx buffer type field.">rfm12_rx_type()</a>, <a class="el" href="rfm12_8c.html#adf41f135b72ab0966e5cc43d20d9d864" title="Function to clear buffer complete/occupied status.">rfm12_rx_clear()</a> and <a class="el" href="structrf__rx__buffer__t.html" title="The receive buffer structure.">rf_rx_buffer_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adf41f135b72ab0966e5cc43d20d9d864"></a><!-- doxytag: member="rfm12.h::rfm12_rx_clear" ref="adf41f135b72ab0966e5cc43d20d9d864" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rfm12_rx_clear </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to clear buffer complete/occupied status. </p>
<p>This function will set the current receive buffer status to free and switch to the other buffer, which can then be read using <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201" title="Inline function to return the rx buffer status byte.">rfm12_rx_status()</a>, <a class="el" href="rfm12_8h.html#a118185e669a176439c45420f68967b84" title="Inline function to return the rx buffer length field.">rfm12_rx_len()</a>, <a class="el" href="rfm12_8h.html#ab1e11af920e7f39c601bd42912debb5b" title="Inline function to return the rx buffer type field.">rfm12_rx_type()</a>, <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a> and <a class="el" href="rfm12_8h.html#ae4ba747a4678e4bba777437be15fb6e3" title="Buffers and status to receive packets.">rf_rx_buffers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a118185e669a176439c45420f68967b84"></a><!-- doxytag: member="rfm12.h::rfm12_rx_len" ref="a118185e669a176439c45420f68967b84" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t rfm12_rx_len </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inline function to return the rx buffer length field. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the data inside the buffer </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201" title="Inline function to return the rx buffer status byte.">rfm12_rx_status()</a>, <a class="el" href="rfm12_8h.html#ab1e11af920e7f39c601bd42912debb5b" title="Inline function to return the rx buffer type field.">rfm12_rx_type()</a>, <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a>, <a class="el" href="rfm12_8c.html#adf41f135b72ab0966e5cc43d20d9d864" title="Function to clear buffer complete/occupied status.">rfm12_rx_clear()</a> and <a class="el" href="structrf__rx__buffer__t.html" title="The receive buffer structure.">rf_rx_buffer_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac5f459ab0857af6cd3651d03b1f0d201"></a><!-- doxytag: member="rfm12.h::rfm12_rx_status" ref="ac5f459ab0857af6cd3651d03b1f0d201" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t rfm12_rx_status </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inline function to return the rx buffer status byte. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>STATUS_FREE or STATUS_COMPLETE </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8h.html#rxtx_states">rx buffer states</a>, <a class="el" href="rfm12_8h.html#a118185e669a176439c45420f68967b84" title="Inline function to return the rx buffer length field.">rfm12_rx_len()</a>, <a class="el" href="rfm12_8h.html#ab1e11af920e7f39c601bd42912debb5b" title="Inline function to return the rx buffer type field.">rfm12_rx_type()</a>, <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a>, <a class="el" href="rfm12_8c.html#adf41f135b72ab0966e5cc43d20d9d864" title="Function to clear buffer complete/occupied status.">rfm12_rx_clear()</a> and <a class="el" href="structrf__rx__buffer__t.html" title="The receive buffer structure.">rf_rx_buffer_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1e11af920e7f39c601bd42912debb5b"></a><!-- doxytag: member="rfm12.h::rfm12_rx_type" ref="ab1e11af920e7f39c601bd42912debb5b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t rfm12_rx_type </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inline function to return the rx buffer type field. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The packet type from the packet header type field </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201" title="Inline function to return the rx buffer status byte.">rfm12_rx_status()</a>, <a class="el" href="rfm12_8h.html#a118185e669a176439c45420f68967b84" title="Inline function to return the rx buffer length field.">rfm12_rx_len()</a>, <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a>, <a class="el" href="rfm12_8c.html#adf41f135b72ab0966e5cc43d20d9d864" title="Function to clear buffer complete/occupied status.">rfm12_rx_clear()</a> and <a class="el" href="structrf__rx__buffer__t.html" title="The receive buffer structure.">rf_rx_buffer_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac5f9a9b05964d24b485e5501cfbb98a4"></a><!-- doxytag: member="rfm12.h::rfm12_start_tx" ref="ac5f9a9b05964d24b485e5501cfbb98a4" args="(uint8_t type, uint8_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfm12_start_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue an already buffered packet for transmission. </p>
<p>If there is no active transmission, the packet header is written to the transmission control buffer and the packet will be enqueued for transmission. <br/>
 This function is not responsible for buffering the actual packet data. The data has to be copied into the transmit buffer beforehand, which can be accomplished by the <a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that this function does not start the transmission, it merely enqueues the packet. <br/>
 Transmissions are started by <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>[type]</em>&nbsp;</td><td>The packet header type field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>[length]</em>&nbsp;</td><td>The packet data length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of these defines: <a class="el" href="rfm12_8h.html#tx_retvals">TX return values</a> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> and <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae928504f5cf2cbe4f894affc4faa2398"></a><!-- doxytag: member="rfm12.h::rfm12_tick" ref="ae928504f5cf2cbe4f894affc4faa2398" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rfm12_tick </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The tick function implements collision avoidance and initiates transmissions. </p>
<p>This function has to be called periodically. It will read the rfm12 status register to check if a carrier is being received, which would indicate activity on the chosen radio channel. <br/>
 If there has been no activity for long enough, the channel is believed to be free.</p>
<p>When there is a packet waiting for transmission and the collision avoidance algorithm indicates that the air is free, then the interrupt control variables are setup for packet transmission and the rfm12 is switched to transmit mode. This function also fills the rfm12 tx fifo with a preamble.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Warning, if you do not call this function periodically, then no packet will get transmitted. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> and <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e9c9b38d4436b312818b8544d6d19bd"></a><!-- doxytag: member="rfm12.h::rfm12_tx" ref="a6e9c9b38d4436b312818b8544d6d19bd" args="(uint8_t len, uint8_t type, uint8_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfm12_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a packet to the buffer and call <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> to enqueue it for transmission. </p>
<p>If there is no active transmission, the buffer contents will be copied to the internal transmission buffer. Finally the buffered packet is going to be enqueued by calling <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a>. If automatic buffering of packet data is not necessary, which is the case when the packet data does not change while the packet is enqueued for transmission, then one could directly store the data in <a class="el" href="rfm12_8h.html#a4ad66f792bc6bccaf10747e4966d80f1">rf_tx_buffer</a> (see <a class="el" href="structrf__tx__buffer__t.html" title="The transmission buffer structure.">rf_tx_buffer_t</a>) and use the <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that this function does not start the transmission, it merely enqueues the packet. <br/>
 Transmissions are started by <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>[len]</em>&nbsp;</td><td>The packet data length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>[type]</em>&nbsp;</td><td>The packet header type field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>[data]</em>&nbsp;</td><td>Pointer to the packet data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of these defines: <a class="el" href="rfm12_8h.html#tx_retvals">TX return values</a> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> and <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a> </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ac0e4e98fdca8a1582a541fac7351b08d"></a><!-- doxytag: member="rfm12.h::ctrl" ref="ac0e4e98fdca8a1582a541fac7351b08d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrfm12__control__t.html">rfm12_control_t</a> <a class="el" href="rfm12_8h.html#ac0e4e98fdca8a1582a541fac7351b08d">ctrl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global control and status. </p>

</div>
</div>
<a class="anchor" id="ae4ba747a4678e4bba777437be15fb6e3"></a><!-- doxytag: member="rfm12.h::rf_rx_buffers" ref="ae4ba747a4678e4bba777437be15fb6e3" args="[2]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrf__rx__buffer__t.html">rf_rx_buffer_t</a> <a class="el" href="rfm12_8h.html#ae4ba747a4678e4bba777437be15fb6e3">rf_rx_buffers</a>[2]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Buffers and status to receive packets. </p>

</div>
</div>
<a class="anchor" id="a4ad66f792bc6bccaf10747e4966d80f1"></a><!-- doxytag: member="rfm12.h::rf_tx_buffer" ref="a4ad66f792bc6bccaf10747e4966d80f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrf__tx__buffer__t.html">rf_tx_buffer_t</a> <a class="el" href="rfm12_8h.html#a4ad66f792bc6bccaf10747e4966d80f1">rf_tx_buffer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Buffer and status for packet transmission. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>
<span style="float:left" ><a href="http://www.das-labor.org"><img src="labor.png" style="border:0px" /><br /><b>Das LABOR</b></a></span>
Generated on Tue Nov 3 17:18:05 2009 for rfm12lib by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1</small></address>
</body>
</html>
