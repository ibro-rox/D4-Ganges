<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>rfm12lib: rfm12lib Library Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Source&nbsp;Documentation</span></a></li>
      <li><a href="globals.html"><span>Alphabetical&nbsp;Index</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>rfm12lib Library Documentation</h1><h3>Version 1.0.0 </h3><div align="center">
<img src="avr_rfm12.png" alt="avr_rfm12.png"/>
<p><strong>rfm12lib</strong></p></div>
 <h2><a class="anchor" id="intro_sec">
Introduction</a></h2>
<p>rfm12lib is an open source library for Atmel AVR microcontrollers that allows you to hook up RF12 modules (<a href="http://www.hoperf.com/pro/RFM12.html">RFM12</a>) from <a href="http://www.hoperf.com/">HopeRF</a> to your microcontroller and add wireless functionaility to your project. It is written in C and requires the free AVR-GCC compiler. The library supports modules of all frequency bands.</p>
<p>This documentation will give you a short overview on how to connect and operate the RF12 modules. It assumes that you have some prior knowledge of C programming. However, no special knowledge about the modules or wireless communication is necessary, unless you want to hack the library itself. The documentation only covers the user API, but excludes library internals. If you wish to extend the library, please have a look at the source code itself, as it claims to be commented quite thoroughly.</p>
<p>Got the library but no modules yet?<br/>
 There are several suppliers of the RFM12. If you happen to live in germany and need low quantities, you could have a look at the <a href="http://www.pollin.de/">pollin online store</a>, which sells them but tends to be expensive. If you need quantities above 10 modules, you are advised to contact the manufacturer directly, as they might be cheaper overall (including shipping). Otherwise, Google is your friend.</p>
<p>The library and all its sources are licensed under the terms of the GPL version 2 or later.</p>
<p>The project page of this library might contain some additional information, as well as the <b>download links</b>. <br/>
 It is located here: <a href="http://www.das-labor.org/wiki/RFM12_library/en"><b>http://www.das-labor.org/wiki/RFM12_library/en</b></a> (also available in <a href="http://www.das-labor.org/wiki/RFM12_library"><b>German</b></a>).</p>
<p>If you have any comments, suggestions or bug reports, please don't hesitate to contact us via <b>info &lt;&Auml;T&gt; das-labor.org</b> . <br/>
 We're also happy to receive patches, given the case you already modified the library and added or changed some meaningful stuff.</p>
<h2><a class="anchor" id="feat_sec">
Library Features</a></h2>
<ul>
<li>Basic packet format, including:<ul>
<li>An 8-bit (0..255) packet type or address field</li>
<li>Packet length up to 255 bytes</li>
<li>A simple header checksum</li>
</ul>
</li>
<li>Interrupt or polling based packet transfer handling</li>
<li>Multiple frequency bands, depending on the used module (433, 868 and 915 MHz)</li>
<li>Collision avoidance (carrier sense)</li>
<li>Usage of synchronization patterns to start data reception</li>
<li>Hardware or software SPI support</li>
<li>Transmit only mode, to reduce the size of the binary</li>
<li>Basic ASK (amplitude shift keying) receive and transmit functionality (for radio controlled outlets and the like)</li>
<li>Low-battery detection feature (using the RFM12)</li>
<li>Low-power Wakeup timer feature (using the RFM12)</li>
</ul>
<p><a class="el" href="extra_features.html">This page</a> has a more in-depth explanation and usage description of the extra features.</p>
<h2><a class="anchor" id="getstarted_sec">
Getting Started</a></h2>
<p>Although it is recommended to have a look at the documentation first, you could also just begin to use the library.</p>
<p>You will have to connect the module to your AVR microcontroller. The section <a class="el" href="index.html#hard_sec">hardware</a> explains how to connect the module. Otherwise it's enough to just solder the SPI port pins appropriately to the hardware SPI port of your AVR and connect the slave select pin anywhere. In case you are using software SPI, you are free to solder the SPI connections to any port pin of the AVR and define the connections in software. Be sure to add an antenna to your module. Usually a short strip of wire is enough. If you want to have a nicely resonating antenna, use an online calculator to get the right length for a whip (1/4 wave) antenna. The optimal length for 433MHz is about 17,5cm or 7 inches. However, any shorter strip of wire usually suffices.</p>
<p>Next you will have to download the library (if you haven't done so yet) and place it somewhere next to your source folder.</p>
<p>In order to run, the library will need some configuration, which is stored in a header file usually named rfm12_config.h. See the section <a class="el" href="index.html#conf_sec">Configuration</a> for more information on how to configure the library. Otherwise just take the demo configuration header from the library folder, put into your source folder and change the values to your needs. The library itself will not include the configuration file, you have to do this manually before including the <a class="el" href="rfm12_8h.html" title="rfm12 library main header">rfm12.h</a> header. However, the <a class="el" href="rfm12_8c.html" title="rfm12 library main file">rfm12.c</a> file will need a special wrapper.</p>
<p>To use the library with your project, it's advised to create two wrapper files, which will simplify your makefile and include the library configuration. Just create two files, <b>rfm12.c</b> and <b>rfm12.h</b> inside your source folder and include the RFM12 configuration header (usually rfm12_config.h), as well as the real <a class="el" href="rfm12_8c.html" title="rfm12 library main file">rfm12.c</a> and <a class="el" href="rfm12_8h.html" title="rfm12 library main header">rfm12.h</a>. <br/>
 Here's an example:</p>
<p><b>rfm12.h</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;rfm12_config.h&quot;</span>
<span class="preprocessor"> #include &quot;../rfm12lib/rfm12.h&quot;</span>
</pre></div><p><b>rfm12.c</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;rfm12_config.h&quot;</span>
<span class="preprocessor"> #include &quot;../rfm12lib/rfm12.c&quot;</span>
</pre></div><p>This way the configuration is correctly supplied to the library and you will only need to add <a class="el" href="rfm12_8c.html" title="rfm12 library main file">rfm12.c</a> to your makefile or project to compile the library.</p>
<p>Finally, you just need to include your <b>rfm12.h</b> to use the library!</p>
<h2><a class="anchor" id="use_sec">
Using the Library</a></h2>
<p>Using the library to transmit or receive data packets turns out to be incredibly simple. <br/>
 Just do the following:</p>
<ul>
<li>At the beginning of your application, call <a class="el" href="rfm12_8c.html#a435d3650bfc7c165fb430a8d4527ef7b" title="This is the main library initialization function.">rfm12_init()</a> once to initialize the module</li>
<li>Call <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a> periodically, as it will maintain the collision avoidance and start transferring your enqueued packets</li>
<li>Use the <a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> function to enqueue a packet for transmission</li>
<li>Check if a packet has been received via <a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201" title="Inline function to return the rx buffer status byte.">rfm12_rx_status()</a></li>
<li>Read packet length, type and contents using <a class="el" href="rfm12_8h.html#a118185e669a176439c45420f68967b84" title="Inline function to return the rx buffer length field.">rfm12_rx_len()</a>, <a class="el" href="rfm12_8h.html#ab1e11af920e7f39c601bd42912debb5b" title="Inline function to return the rx buffer type field.">rfm12_rx_type()</a>, <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a></li>
<li>Be sure to clear the received packet buffer after reading a packet by calling <a class="el" href="rfm12_8c.html#adf41f135b72ab0966e5cc43d20d9d864" title="Function to clear buffer complete/occupied status.">rfm12_rx_clear()</a></li>
<li>If you are using polling instead of the interrupt, you have to call rfm12_poll() periodically to transmit and receive packets. <br/>
 rfm12_poll() has to be called a lot more often than <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>, as it needs to fill or read the 1-byte FIFO of the RFM12 for every byte in a transmission.</li>
</ul>
<p>Click the function name links to get to the documentation.</p>
<p>A simple main method to transmit some packets merely consists of the following: </p>
<div class="fragment"><pre class="fragment"> uint8_t teststring[] = <span class="stringliteral">&quot;teststring\r\n&quot;</span>;
 uint8_t packettype = 0xEE;
 <a class="code" href="rfm12_8c.html#a435d3650bfc7c165fb430a8d4527ef7b" title="This is the main library initialization function.">rfm12_init</a>();  <span class="comment">/* initialize the library */</span>
 sei();
 
 <span class="keywordflow">while</span> (23)
 {
   <span class="comment">/* ... */</span>
   <a class="code" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx</a> (<span class="keyword">sizeof</span>(teststring), packettype, teststring);
   <a class="code" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick</a>();  <span class="comment">/* periodic tick function - call that one once in a while */</span>
 }
</pre></div><p>There are several extra features. They are explained <a class="el" href="extra_features.html">here</a>.</p>
<p>Some example projects for an ATmega8 can be found in the subdirectory <b>test-m8</b>.</p>
<h2><a class="anchor" id="hard_sec">
Hardware</a></h2>
<p>If you are using hardware SPI, which is the default, connect the RFM12 to the AVR as follows: </p>
<div class="fragment"><pre class="fragment">
RFM12           | AVR
----------------+------------
SDO             | MISO
nIRQ            | INT0
FSK/DATA/nFFS   | VCC
DCLK/CFIL/FFIT  |  -
CLK             |  -
nRES            |  -
GND             | GND
ANT             |  -
VDD             | VCC
GND             | GND
nINT/VDI        | -
SDI             | MOSI
SCK             | SCK
nSEL            | Slave select pin defined below
</pre></div><p>For software SPI users just connect the SDI, SDO and SCK pins of the RF12 module to meaningful pins on your microcontroller and adapt the configuration header.</p>
<p><a href="http://www.hoperf.com/pdf/RFM12.pdf">Here's</a> the RFM12 datasheet for the pinout and <a href="http://www.hoperf.com/pdf/RF12.pdf">here's</a> the datasheet of the transceiver IC.</p>
<h2><a class="anchor" id="conf_sec">
Configuration</a></h2>
<p>The configuration file is split into several sections which are explained below. The library source folder contains a demo configuration file for reference, namely rfm12_config.h.demo.</p>
<h3><a class="anchor" id="conf_pins_sec">
Pin Configuration</a></h3>
<p>The following configuration is necessary for hardware SPI (default). You just need to adjust the port names and pin numbers (The example uses PORTB/PINB/DDRB). Please refer to your specific AVR datasheet for more information on these names and numbers.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">//Pin that the RFM12&apos;s slave select is connected to</span>
<span class="preprocessor"> #define DDR_SS DDRB</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PORT_SS PORTB</span>
<span class="preprocessor"></span><span class="preprocessor"> #define BIT_SS 2</span>
<span class="preprocessor"></span> 
 <span class="comment">//SPI port</span>
<span class="preprocessor"> #define DDR_SPI DDRB</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PORT_SPI PORTB</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PIN_SPI PINB</span>
<span class="preprocessor"></span><span class="preprocessor"> #define BIT_MOSI 3</span>
<span class="preprocessor"></span><span class="preprocessor"> #define BIT_MISO 4</span>
<span class="preprocessor"></span><span class="preprocessor"> #define BIT_SCK  5</span>
<span class="preprocessor"> #define BIT_SPI_SS 2</span>
</pre></div><p> The BIT_SPI_SS define is the hardware SS pin of the AVR, it needs to be set to output for the spi-interface to work correctly independently of the CS pin used for the RFM12.</p>
<p>For software SPI, you shall use the following configuration. Again, you just need to adjust the port and pin names. This example uses PORTA and PORTC and their respective input (PIN) and direction (DDR) registers.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">//SPI MOSI port</span>
<span class="preprocessor"> #define DDR_MOSI DDRA</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PORT_MOSI PORTA</span>
<span class="preprocessor"></span>
 <span class="comment">//SPI MISO port</span>
<span class="preprocessor"> #define DDR_MISO DDRA</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PIN_MISO PINA</span>
<span class="preprocessor"></span>
 <span class="comment">//SPI SCK port</span>
<span class="preprocessor"> #define DDR_SCK DDRC</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PORT_SCK PORTC</span>
<span class="preprocessor"></span>
 <span class="comment">//SPI SS port</span>
<span class="preprocessor"> #define DDR_SPI_SS DDRC</span>
<span class="preprocessor"></span><span class="preprocessor"> #define PORT_SPI_SS PORTC </span>
<span class="preprocessor"></span>
 <span class="comment">//SPI pin numbers on their respective ports</span>
<span class="preprocessor"> #define BIT_MOSI 3</span>
<span class="preprocessor"></span><span class="preprocessor"> #define BIT_MISO 4</span>
<span class="preprocessor"></span><span class="preprocessor"> #define BIT_SCK  3</span>
<span class="preprocessor"> #define BIT_SPI_SS 4</span>
</pre></div><p> Even when you are using hardware SPI, you could still use this more detailed pin configuration, but then you still have to include the hardware SPI SS defines and match the port and pins to your hardware SPI port.</p>
<h3><a class="anchor" id="conf_rfm12_sec">
RFM12 Configuration</a></h3>
<p>The following section configures RFM12 related stuff, such as the exact frequency to use, the baudrate and the buffer sizes.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">//baseband of the module (either RFM12_BAND_433, RFM12_BAND_868 or RFM12_BAND_912)</span>
<span class="preprocessor"> #define RFM12_BASEBAND RFM12_BAND_433</span>
<span class="preprocessor"></span> 
 <span class="comment">//center frequency to use (+-125kHz FSK frequency shift)</span>
<span class="preprocessor"> #define FREQ 433175000UL</span>
<span class="preprocessor"></span> 
 <span class="comment">//use this for datarates &gt;= 2700 Baud</span>
<span class="preprocessor"> #define DATARATE_VALUE RFM12_DATARATE_CALC_HIGH(9600.0)</span>
<span class="preprocessor"></span> 
 <span class="comment">//use this for 340 Baud &lt; datarate &lt; 2700 Baud</span>
 <span class="comment">//#define DATARATE_VALUE RFM12_DATARATE_CALC_LOW(1200.0)</span>
 
 <span class="comment">//TX BUFFER SIZE</span>
<span class="preprocessor"> #define RFM12_TX_BUFFER_SIZE 30</span>
<span class="preprocessor"></span> 
 <span class="comment">//RX BUFFER SIZE (there are going to be 2 Buffers of this size for double_buffering)</span>
<span class="preprocessor"> #define RFM12_RX_BUFFER_SIZE 30 </span>
</pre></div><p>The frequency has to be in the frequency band of your module. This is only the center frequency, the module will need +-125kHz for modulation. The maximum baud rate is 115.2 kbps. <br/>
 Please note that the buffers will consume ram, so be careful when making them larger. <br/>
 If you set all buffers to 255 bytes, which is the maximum packet size, then you will consume 3 * 255 bytes of ram.</p>
<h3><a class="anchor" id="conf_int_sec">
Interrupt Configuration</a></h3>
<p>The RFM12 may use an interrupt to signal various events to the microcontroller. As this library utilizes the interrupt, you must configure the right interrupt for your AVR device. Please refer to your specific AVR datasheet for more information on the external interrupts. The interrupt has to be an external interrupt pin, triggering on a negative edge.</p>
<p>The following code-snippet configures the interrupt for an ATmega8 to external interrupt 1.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">//the interrupt vector</span>
<span class="preprocessor"> #define RFM12_INT_VECT (INT1_vect)</span>
<span class="preprocessor"></span> 
 <span class="comment">//the interrupt mask register</span>
<span class="preprocessor"> #define RFM12_INT_MSK GICR</span>
<span class="preprocessor"></span> 
 <span class="comment">//the interrupt bit in the mask register</span>
<span class="preprocessor"> #define RFM12_INT_BIT (INT1)</span>
<span class="preprocessor"></span> 
 <span class="comment">//the interrupt flag register</span>
<span class="preprocessor"> #define RFM12_INT_FLAG GIFR</span>
<span class="preprocessor"></span> 
 <span class="comment">//the interrupt bit in the flag register</span>
<span class="preprocessor"> #define RFM12_FLAG_BIT (INTF1)</span>
<span class="preprocessor"></span> 
 <span class="comment">//setup the interrupt to trigger on negative edge</span>
<span class="preprocessor"> #define RFM12_INT_SETUP()   MCUCR |= (1&lt;&lt;ISC11)</span>
</pre></div><h3><a class="anchor" id="conf_feature_sec">
Feature Configuration</a></h3>
<p>The following default code configures the extra features of the library. See <a class="el" href="extra_features.html">extra features</a> for further explanation.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define RFM12_LIVECTRL 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_NORETURNS 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_NOCOLLISIONDETECTION 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_TRANSMIT_ONLY 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_SPI_SOFTWARE 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_USE_POLLING 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_RECEIVE_ASK 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_TRANSMIT_ASK 0</span>
<span class="preprocessor"></span><span class="preprocessor"> #define RFM12_USE_WAKEUP_TIMER 0</span>
<span class="preprocessor"> #define RFM12_LOW_POWER 0 </span>
</pre></div><p>Set <b>RFM12_LIVECTRL</b> to 1 to enable a set of functions which allow runtime reconfiguration of the frequency and baud rate. They are disabled by default to reduce the size of the binary. See <a class="el" href="rfm12__ctrl_8h.html" title="rfm12 library live control feature header">rfm12_ctrl.h</a> for the functions.</p>
<p>Set <b>RFM12_NORETURNS</b> to 1 to disable the return values of the transmit functions. This saves some bytes (although very few) in the binary.</p>
<p>Set <b>RFM12_NOCOLLISIONDETECTION</b> to 1 to disable the collision avoidance. This will speed up <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a> and save a consideable amount of bytes in the binary. When using transmit only mode, collision avoidance will be disabled anyway, as the receiver is not available then.</p>
<p>Set <b>RFM12_TRANSMIT_ONLY</b> to 1 if you do not need to receive data. This will strip the receiving functionaility of the library completely, reducing the resulting binary size by a considerable amount of bytes. As the receiver is not available to check for active transmissions from other transmitters on the selected frequency, collision avoidance would not work and is disabled in this case.</p>
<p>Set <b>RFM12_SPI_SOFTWARE</b> to 1 if you wish to use software SPI instead of hardware SPI.</p>
<p>Set <b>RFM12_USE_POLLING</b> to 1 in case you do not want to use an interrupt for packet handling. This will enable a function named rfm12_poll() which has to be called periodically to handle packet transfers. rfm12_poll() has to be called a lot more often than <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>, as it needs to fill or read the 1-byte FIFO of the RFM12 for every byte in a transmission.</p>
<p>Set <b>RFM12_RECEIVE_ASK</b> to 1 if you intend to receive ASK (amplitude shift keying) modulated data. Usually this module cannot do that, but with some soldering and an extra ADC interrupt, you still can receive data from simple devices such as thermometers or wireless outlets, which tend to use ASK. Note that this feature will use the ADC interrupt of your AVR. See <a class="el" href="rfm12__extra_8h.html" title="rfm12 library extra features header">rfm12_extra.h</a> for the functions.</p>
<p>Set <b>RFM12_TRANSMIT_ASK</b> to 1 if you also want to send ASK modulated data. This will provide you with a set of functions to switch into ASK transmit mode and to enable or disable the transceiver. Obviously this is a hack. You can emaulate ASK modulated signals with this, by turning on and off the transmitter, which translates into some amplitude (1) or no amplitude (0). Unfortunately you have to do the proper bit timing and transmit function yourself. See <a class="el" href="rfm12__extra_8h.html" title="rfm12 library extra features header">rfm12_extra.h</a> for the functions.</p>
<p>Set <b>RFM12_USE_WAKEUP_TIMER</b> to 1 to use the wakeup timer feature of the RFM12. When enabling this, there will be a function to set the wakeup timer, and the interrupt will handle wakeup events. You can use this to put your AVR into sleep mode and let him wake up periodically. This way you can save huge amounts of power and run your application off of goldcaps for some time or increase battery life. Sometimes the wakeup timer feature works unstable and requires fine tuning of your application. See <a class="el" href="extra_features.html">Extra Features</a> for more help on this topic. <a class="el" href="rfm12__extra_8h.html" title="rfm12 library extra features header">rfm12_extra.h</a> contains the functions.</p>
<p>Set <b>RFM12_LOW_POWER</b> to 1 to use the low-battery detector feature of the RFM12. If this feature is enabled, the interrupt will recognize a low battery voltage alert from the RFM12. There are functions in <a class="el" href="rfm12__extra_8h.html" title="rfm12 library extra features header">rfm12_extra.h</a> to set the specific warning voltage and to read the current battery status.</p>
<h2><a class="anchor" id="tech_sec">
Technical Details</a></h2>
<p>The library utilizes the digital SPI interface of the module for communication. The RFM12 is operated in FIFO mode in conjunction with an interrupt output to signal various operating states to the microcontroller. Additional module configuration includes automatic frequency correction in receive mode, as well as sync pattern detection. The sync pattern detection feature of the RFM12 starts filling the receive FIFO only when a predefined synchronization pattern has been received. The specific pattern is prepended automatically to every packet before transmission by the library.</p>
<p>The library implements a basic packet format with a one byte type or address field, a one byte length field and a simple crc check over the header. As the RFM12 only has a 1-byte FIFO, all packet data transfers from and to the device are encapsulated by an interrupt and several API functions. Due to this encapsulation, packet header crc values can be generated and verified automatically. Invalid packets are silently dropped without user notice.</p>
<p>To minimize erroneous packet transfers, a simple collision avoidance algorithm has been implemented. All packet transfers are enqueued into an internal buffer before transmission. A periodically called function (<a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>) measures if a carrier signal is present, and if so, inhibits further packet transfers for a settable time. If the selected frequency is free long enough, an enqueud packet transfer will be started by <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>.</p>
<p>The interrupt handles FIFO over- and underflow, low-battery detection and wakeup timer events. If a FIFO interrupt occurs, the current operating state is determined (receiving or transmitting) and the next byte is either read or written to or from the FIFO.</p>
<p>See <a class="el" href="extra_features.html">extra features</a> for more details about the extra features.</p>
<h2><a class="anchor" id="credits_sec">
Credits</a></h2>
<p>The library has been created by Hans-Gert Dahmen and Peter Fuhrmann. Some of the extra features have been implemented by Soeren Heisrath. All main authors are members of <a href="http://www.das-labor.org/">Das LABOR</a>, a hackerspace in Germany. Thanks to Das LABOR for providing the great infrastructure and environment!</p>
<p>Thanks to Alexander Krause for contributing a patch that allows frequency bands other than 433MHz to be used. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>
<span style="float:left" ><a href="http://www.das-labor.org"><img src="labor.png" style="border:0px" /><br /><b>Das LABOR</b></a></span>
Generated on Tue Nov 3 17:18:04 2009 for rfm12lib by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1</small></address>
</body>
</html>
