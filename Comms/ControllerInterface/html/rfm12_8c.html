<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>rfm12lib: rfm12.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Source&nbsp;Documentation</span></a></li>
      <li><a href="globals.html"><span>Alphabetical&nbsp;Index</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>rfm12.c File Reference</h1>
<p>rfm12 library main file  
<a href="#_details">More...</a></p>
<code>#include &lt;avr/io.h&gt;</code><br/>
<code>#include &lt;avr/interrupt.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;include/rfm12_hw.h&quot;</code><br/>
<code>#include &quot;include/rfm12_core.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="rfm12_8h_source.html">rfm12.h</a>&quot;</code><br/>
<code>#include &quot;include/rfm12_spi.c&quot;</code><br/>
<code>#include &quot;<a class="el" href="rfm12__ctrl_8c.html">include/rfm12_ctrl.c</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rfm12__extra_8c.html">include/rfm12_extra.c</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#a857bd06bc1faa8d57a3bfccd775510ce">ISR</a> (RFM12_INT_VECT, ISR_NOBLOCK)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt handler to handle all transmit and receive data transfers to the rfm12.  <a href="#a857bd06bc1faa8d57a3bfccd775510ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398">rfm12_tick</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The tick function implements collision avoidance and initiates transmissions.  <a href="#ae928504f5cf2cbe4f894affc4faa2398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4">rfm12_start_tx</a> (uint8_t type, uint8_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enqueue an already buffered packet for transmission.  <a href="#ac5f9a9b05964d24b485e5501cfbb98a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd">rfm12_tx</a> (uint8_t len, uint8_t type, uint8_t *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a packet to the buffer and call <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> to enqueue it for transmission.  <a href="#a6e9c9b38d4436b312818b8544d6d19bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#adf41f135b72ab0966e5cc43d20d9d864">rfm12_rx_clear</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to clear buffer complete/occupied status.  <a href="#adf41f135b72ab0966e5cc43d20d9d864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#a435d3650bfc7c165fb430a8d4527ef7b">rfm12_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the main library initialization function.  <a href="#a435d3650bfc7c165fb430a8d4527ef7b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrf__tx__buffer__t.html">rf_tx_buffer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#a4ad66f792bc6bccaf10747e4966d80f1">rf_tx_buffer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffer and status for packet transmission.  <a href="#a4ad66f792bc6bccaf10747e4966d80f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrf__rx__buffer__t.html">rf_rx_buffer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#ae4ba747a4678e4bba777437be15fb6e3">rf_rx_buffers</a> [2]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffers and status to receive packets.  <a href="#ae4ba747a4678e4bba777437be15fb6e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrfm12__control__t.html">rfm12_control_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rfm12_8c.html#ac0e4e98fdca8a1582a541fac7351b08d">ctrl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global control and status.  <a href="#ac0e4e98fdca8a1582a541fac7351b08d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>rfm12 library main file </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Hans-Gert Dahmen </dd>
<dd>
Peter Fuhrmann </dd>
<dd>
Soeren Heisrath </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.9.0 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>08.09.09</dd></dl>
<p>All core functionality is implemented within this file. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a857bd06bc1faa8d57a3bfccd775510ce"></a><!-- doxytag: member="rfm12.c::ISR" ref="a857bd06bc1faa8d57a3bfccd775510ce" args="(RFM12_INT_VECT, ISR_NOBLOCK)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ISR </td>
          <td>(</td>
          <td class="paramtype">RFM12_INT_VECT&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISR_NOBLOCK&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interrupt handler to handle all transmit and receive data transfers to the rfm12. </p>
<p>The receiver will generate an interrupt request (IT) for the microcontroller - by pulling the nIRQ pin low - on the following events:</p>
<ul>
<li>The TX register is ready to receive the next byte (RGIT)</li>
<li>The FIFO has received the preprogrammed amount of bits (FFIT)</li>
<li>Power-on reset (POR)</li>
<li>FIFO overflow (FFOV) / TX register underrun (RGUR)</li>
<li>Wake-up timer timeout (WKUP)</li>
<li>Negative pulse on the interrupt input pin nINT (EXT)</li>
<li>Supply voltage below the preprogrammed value is detected (LBD)</li>
</ul>
<p>The rfm12 status register is read to determine which event has occured. Reading the status register will clear the event flags.</p>
<p>The interrupt handles the RGIT and FFIT events by default. Upon specific configuration of the library the WKUP and LBD events are handled additionally.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structrfm12__control__t.html" title="Control and status structure.">rfm12_control_t</a>, <a class="el" href="structrf__rx__buffer__t.html" title="The receive buffer structure.">rf_rx_buffer_t</a> and <a class="el" href="structrf__tx__buffer__t.html" title="The transmission buffer structure.">rf_tx_buffer_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a435d3650bfc7c165fb430a8d4527ef7b"></a><!-- doxytag: member="rfm12.c::rfm12_init" ref="a435d3650bfc7c165fb430a8d4527ef7b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rfm12_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the main library initialization function. </p>
<p>This function takes care of all module initialization, including:</p>
<ul>
<li>Setup of the used frequency band and external capacitor</li>
<li>Setting the exact frequency (channel)</li>
<li>Setting the transmission data rate</li>
<li>Configuring various module related rx parameters, including the amplification</li>
<li>Enabling the digital data filter</li>
<li>Enabling the use of the modules fifo, as well as enabling sync pattern detection</li>
<li>Configuring the automatic frequency correction</li>
<li>Setting the transmit power</li>
</ul>
<p>This initialization function also sets up various library internal configuration structs and puts the module into receive mode before returning.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Please note that the transmit power and receive amplification values are currently hard coded. Have a look into rfm12_hw.h for possible settings. </dd></dl>

</div>
</div>
<a class="anchor" id="adf41f135b72ab0966e5cc43d20d9d864"></a><!-- doxytag: member="rfm12.c::rfm12_rx_clear" ref="adf41f135b72ab0966e5cc43d20d9d864" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rfm12_rx_clear </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to clear buffer complete/occupied status. </p>
<p>This function will set the current receive buffer status to free and switch to the other buffer, which can then be read using <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8h.html#ac5f459ab0857af6cd3651d03b1f0d201" title="Inline function to return the rx buffer status byte.">rfm12_rx_status()</a>, <a class="el" href="rfm12_8h.html#a118185e669a176439c45420f68967b84" title="Inline function to return the rx buffer length field.">rfm12_rx_len()</a>, <a class="el" href="rfm12_8h.html#ab1e11af920e7f39c601bd42912debb5b" title="Inline function to return the rx buffer type field.">rfm12_rx_type()</a>, <a class="el" href="rfm12_8h.html#a0ffa5a87f37bbc2af40850ce265da99b" title="Inline function to retreive current rf buffer contents.">rfm12_rx_buffer()</a> and <a class="el" href="rfm12_8h.html#ae4ba747a4678e4bba777437be15fb6e3" title="Buffers and status to receive packets.">rf_rx_buffers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac5f9a9b05964d24b485e5501cfbb98a4"></a><!-- doxytag: member="rfm12.c::rfm12_start_tx" ref="ac5f9a9b05964d24b485e5501cfbb98a4" args="(uint8_t type, uint8_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfm12_start_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enqueue an already buffered packet for transmission. </p>
<p>If there is no active transmission, the packet header is written to the transmission control buffer and the packet will be enqueued for transmission. <br/>
 This function is not responsible for buffering the actual packet data. The data has to be copied into the transmit buffer beforehand, which can be accomplished by the <a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that this function does not start the transmission, it merely enqueues the packet. <br/>
 Transmissions are started by <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>[type]</em>&nbsp;</td><td>The packet header type field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>[length]</em>&nbsp;</td><td>The packet data length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of these defines: <a class="el" href="rfm12_8h.html#tx_retvals">TX return values</a> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> and <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae928504f5cf2cbe4f894affc4faa2398"></a><!-- doxytag: member="rfm12.c::rfm12_tick" ref="ae928504f5cf2cbe4f894affc4faa2398" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rfm12_tick </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The tick function implements collision avoidance and initiates transmissions. </p>
<p>This function has to be called periodically. It will read the rfm12 status register to check if a carrier is being received, which would indicate activity on the chosen radio channel. <br/>
 If there has been no activity for long enough, the channel is believed to be free.</p>
<p>When there is a packet waiting for transmission and the collision avoidance algorithm indicates that the air is free, then the interrupt control variables are setup for packet transmission and the rfm12 is switched to transmit mode. This function also fills the rfm12 tx fifo with a preamble.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Warning, if you do not call this function periodically, then no packet will get transmitted. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8c.html#a6e9c9b38d4436b312818b8544d6d19bd" title="Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission...">rfm12_tx()</a> and <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e9c9b38d4436b312818b8544d6d19bd"></a><!-- doxytag: member="rfm12.c::rfm12_tx" ref="a6e9c9b38d4436b312818b8544d6d19bd" args="(uint8_t len, uint8_t type, uint8_t *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rfm12_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a packet to the buffer and call <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> to enqueue it for transmission. </p>
<p>If there is no active transmission, the buffer contents will be copied to the internal transmission buffer. Finally the buffered packet is going to be enqueued by calling <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a>. If automatic buffering of packet data is not necessary, which is the case when the packet data does not change while the packet is enqueued for transmission, then one could directly store the data in <a class="el" href="rfm12_8h.html#a4ad66f792bc6bccaf10747e4966d80f1">rf_tx_buffer</a> (see <a class="el" href="structrf__tx__buffer__t.html" title="The transmission buffer structure.">rf_tx_buffer_t</a>) and use the <a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that this function does not start the transmission, it merely enqueues the packet. <br/>
 Transmissions are started by <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>[len]</em>&nbsp;</td><td>The packet data length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>[type]</em>&nbsp;</td><td>The packet header type field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>[data]</em>&nbsp;</td><td>Pointer to the packet data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of these defines: <a class="el" href="rfm12_8h.html#tx_retvals">TX return values</a> </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="rfm12_8c.html#ac5f9a9b05964d24b485e5501cfbb98a4" title="Enqueue an already buffered packet for transmission.">rfm12_start_tx()</a> and <a class="el" href="rfm12_8c.html#ae928504f5cf2cbe4f894affc4faa2398" title="The tick function implements collision avoidance and initiates transmissions.">rfm12_tick()</a> </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ac0e4e98fdca8a1582a541fac7351b08d"></a><!-- doxytag: member="rfm12.c::ctrl" ref="ac0e4e98fdca8a1582a541fac7351b08d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrfm12__control__t.html">rfm12_control_t</a> <a class="el" href="rfm12_8h.html#ac0e4e98fdca8a1582a541fac7351b08d">ctrl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Global control and status. </p>

</div>
</div>
<a class="anchor" id="ae4ba747a4678e4bba777437be15fb6e3"></a><!-- doxytag: member="rfm12.c::rf_rx_buffers" ref="ae4ba747a4678e4bba777437be15fb6e3" args="[2]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrf__rx__buffer__t.html">rf_rx_buffer_t</a> <a class="el" href="rfm12_8h.html#ae4ba747a4678e4bba777437be15fb6e3">rf_rx_buffers</a>[2]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Buffers and status to receive packets. </p>

</div>
</div>
<a class="anchor" id="a4ad66f792bc6bccaf10747e4966d80f1"></a><!-- doxytag: member="rfm12.c::rf_tx_buffer" ref="a4ad66f792bc6bccaf10747e4966d80f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrf__tx__buffer__t.html">rf_tx_buffer_t</a> <a class="el" href="rfm12_8h.html#a4ad66f792bc6bccaf10747e4966d80f1">rf_tx_buffer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Buffer and status for packet transmission. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>
<span style="float:left" ><a href="http://www.das-labor.org"><img src="labor.png" style="border:0px" /><br /><b>Das LABOR</b></a></span>
Generated on Tue Nov 3 17:18:05 2009 for rfm12lib by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1</small></address>
</body>
</html>
